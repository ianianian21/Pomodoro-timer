<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/pomodorotimer/MainActivity.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/pomodorotimer/MainActivity.java" />
              <option name="originalContent" value="package com.example.pomodorotimer;&#10;&#10;import android.animation.ObjectAnimator;&#10;import android.app.NotificationChannel;&#10;import android.app.NotificationManager;&#10;import android.content.SharedPreferences;&#10;import android.media.Ringtone;&#10;import android.media.RingtoneManager;&#10;import android.net.Uri;&#10;import android.os.Build;&#10;import android.os.Bundle;&#10;import android.os.CountDownTimer;&#10;import android.os.Vibrator;&#10;import android.widget.Button;&#10;import android.widget.EditText;&#10;import android.widget.ImageButton;&#10;import android.widget.TextView;&#10;&#10;import androidx.activity.EdgeToEdge;&#10;import androidx.appcompat.app.AppCompatActivity;&#10;import androidx.core.app.NotificationCompat;&#10;import androidx.core.app.NotificationManagerCompat;&#10;import androidx.core.content.ContextCompat;&#10;import androidx.core.graphics.Insets;&#10;import androidx.core.view.ViewCompat;&#10;import androidx.core.view.WindowInsetsCompat;&#10;&#10;import com.google.android.material.bottomsheet.BottomSheetDialog;&#10;import com.google.android.material.floatingactionbutton.FloatingActionButton;&#10;import com.google.android.material.progressindicator.CircularProgressIndicator;&#10;&#10;public class MainActivity extends AppCompatActivity {&#10;&#10;    private static final String CHANNEL_ID = &quot;pomodoro_channel&quot;;&#10;&#10;    private TextView textMode;&#10;    private TextView textTimer;&#10;    private TextView textSessions; // new sessions counter&#10;    private ImageButton buttonPlay;&#10;    private ImageButton buttonPause;&#10;    private FloatingActionButton buttonSettings;&#10;    private CircularProgressIndicator circularProgress;&#10;&#10;    private CountDownTimer countDownTimer;&#10;    private boolean isRunning = false;&#10;    private boolean isWorkMode = true;&#10;&#10;    private long workMillis = 25 * 60 * 1000L;&#10;    private long breakMillis = 5 * 60 * 1000L;&#10;    private long timeLeft = workMillis; // milliseconds remaining&#10;&#10;    private int sessionsCompleted = 0; // persisted count&#10;&#10;    private static final String PREFS = &quot;pomodoro_prefs&quot;;&#10;    private static final String KEY_WORK = &quot;work_minutes&quot;;&#10;    private static final String KEY_BREAK = &quot;break_minutes&quot;;&#10;    private static final String KEY_IS_WORK = &quot;is_work&quot;;&#10;    private static final String KEY_TIME_LEFT = &quot;time_left&quot;;&#10;    private static final String KEY_IS_RUNNING = &quot;is_running&quot;;&#10;    private static final String KEY_SESSIONS = &quot;sessions_completed&quot;;&#10;&#10;    @Override&#10;    protected void onCreate(Bundle savedInstanceState) {&#10;        super.onCreate(savedInstanceState);&#10;        EdgeToEdge.enable(this);&#10;        setContentView(R.layout.activity_main);&#10;        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -&gt; {&#10;            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());&#10;            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);&#10;            return insets;&#10;        });&#10;&#10;        bindViews();&#10;        createNotificationChannel();&#10;        loadPreferences();&#10;&#10;        if (savedInstanceState != null) {&#10;            isWorkMode = savedInstanceState.getBoolean(KEY_IS_WORK, true);&#10;            timeLeft = savedInstanceState.getLong(KEY_TIME_LEFT, isWorkMode ? workMillis : breakMillis);&#10;            isRunning = savedInstanceState.getBoolean(KEY_IS_RUNNING, false);&#10;            sessionsCompleted = savedInstanceState.getInt(KEY_SESSIONS, sessionsCompleted);&#10;        } else {&#10;            timeLeft = isWorkMode ? workMillis : breakMillis;&#10;        }&#10;&#10;        updateUi();&#10;&#10;        buttonPlay.setOnClickListener(v -&gt; startTimer());&#10;        buttonPause.setOnClickListener(v -&gt; stopTimer());&#10;        buttonSettings.setOnClickListener(v -&gt; showSettingsSheet());&#10;&#10;        if (isRunning) startTimer();&#10;    }&#10;&#10;    private void bindViews() {&#10;        textMode = findViewById(R.id.text_mode);&#10;        textTimer = findViewById(R.id.text_timer);&#10;        textSessions = findViewById(R.id.text_sessions);&#10;        buttonPlay = findViewById(R.id.button_play);&#10;        buttonPause = findViewById(R.id.button_pause);&#10;        buttonSettings = findViewById(R.id.button_settings);&#10;        circularProgress = findViewById(R.id.circular_progress);&#10;    }&#10;&#10;    private void createNotificationChannel() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            CharSequence name = &quot;Pomodoro Alerts&quot;;&#10;            String description = &quot;Notifications for Pomodoro session events&quot;;&#10;            int importance = NotificationManager.IMPORTANCE_DEFAULT;&#10;            NotificationChannel channel = new NotificationChannel(CHANNEL_ID, name, importance);&#10;            channel.setDescription(description);&#10;            NotificationManager notificationManager = getSystemService(NotificationManager.class);&#10;            if (notificationManager != null) notificationManager.createNotificationChannel(channel);&#10;        }&#10;    }&#10;&#10;    private void showNotification(String title, String text) {&#10;        // Require POST_NOTIFICATIONS on Android 13+ and check notifications are enabled&#10;        try {&#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;                if (ContextCompat.checkSelfPermission(this, android.Manifest.permission.POST_NOTIFICATIONS) != android.content.pm.PackageManager.PERMISSION_GRANTED) {&#10;                    android.util.Log.w(&quot;MainActivity&quot;, &quot;POST_NOTIFICATIONS permission not granted; skipping notification&quot;);&#10;                    return;&#10;                }&#10;            }&#10;&#10;            NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this);&#10;            if (!notificationManager.areNotificationsEnabled()) {&#10;                android.util.Log.w(&quot;MainActivity&quot;, &quot;Notifications are disabled by user; skipping notification&quot;);&#10;                return;&#10;            }&#10;&#10;            Uri soundUri = RingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION);&#10;            NotificationCompat.Builder builder = new NotificationCompat.Builder(this, CHANNEL_ID)&#10;                    .setSmallIcon(R.drawable.ic_launcher_foreground)&#10;                    .setContentTitle(title)&#10;                    .setContentText(text)&#10;                    .setPriority(NotificationCompat.PRIORITY_DEFAULT)&#10;                    .setSound(soundUri)&#10;                    .setAutoCancel(true);&#10;&#10;            try {&#10;                notificationManager.notify((int) System.currentTimeMillis(), builder.build());&#10;            } catch (SecurityException se) {&#10;                android.util.Log.w(&quot;MainActivity&quot;, &quot;Failed to post notification&quot;, se);&#10;                return;&#10;            }&#10;&#10;            // Also play the ringtone immediately (some devices delay notification sound)&#10;            try {&#10;                Ringtone r = RingtoneManager.getRingtone(this, soundUri);&#10;                if (r != null) r.play();&#10;            } catch (Exception ignored) {&#10;                android.util.Log.w(&quot;MainActivity&quot;, &quot;Failed to play notification sound&quot;, ignored);&#10;            }&#10;        } catch (Exception e) {&#10;            android.util.Log.w(&quot;MainActivity&quot;, &quot;showNotification error&quot;, e);&#10;        }&#10;    }&#10;&#10;    private void showSettingsSheet() {&#10;        try {&#10;            BottomSheetDialog dialog = new BottomSheetDialog(this);&#10;            dialog.setContentView(R.layout.bottom_sheet_settings);&#10;&#10;            final EditText bsInputWork = dialog.findViewById(R.id.bs_input_work);&#10;            final EditText bsInputBreak = dialog.findViewById(R.id.bs_input_break);&#10;            Button bsApply = dialog.findViewById(R.id.bs_apply);&#10;&#10;            if (bsInputWork != null) bsInputWork.setText(String.valueOf(workMillis / 60000L));&#10;            if (bsInputBreak != null) bsInputBreak.setText(String.valueOf(breakMillis / 60000L));&#10;&#10;            if (bsApply != null) {&#10;                bsApply.setOnClickListener(v -&gt; {&#10;                    try {&#10;                        // guard against null EditText references or null text&#10;                        if (bsInputWork == null || bsInputBreak == null) {&#10;                            dialog.dismiss();&#10;                            return;&#10;                        }&#10;                        CharSequence wCs = bsInputWork.getText();&#10;                        CharSequence bCs = bsInputBreak.getText();&#10;                        String w = wCs == null ? &quot;&quot; : wCs.toString().trim();&#10;                        String b = bCs == null ? &quot;&quot; : bCs.toString().trim();&#10;                        int wMin = 25;&#10;                        int bMin = 5;&#10;                        if (!w.isEmpty()) wMin = Integer.parseInt(w);&#10;                        if (!b.isEmpty()) bMin = Integer.parseInt(b);&#10;                        if (wMin &lt;= 0) wMin = 1;&#10;                        if (bMin &lt;= 0) bMin = 1;&#10;                        workMillis = wMin * 60 * 1000L;&#10;                        breakMillis = bMin * 60 * 1000L;&#10;                        timeLeft = isWorkMode ? workMillis : breakMillis;&#10;                        savePreferences();&#10;                        updateUi();&#10;                    } catch (Exception ex) {&#10;                        android.util.Log.w(&quot;MainActivity&quot;, &quot;Error parsing settings input&quot;, ex);&#10;                    }&#10;                    dialog.dismiss();&#10;                });&#10;            }&#10;&#10;            dialog.show();&#10;        } catch (Exception ex) {&#10;            // Catch unexpected inflation errors to avoid app crash; fallback to a simple dialog&#10;            android.util.Log.e(&quot;MainActivity&quot;, &quot;Failed to show settings sheet&quot;, ex);&#10;        }&#10;    }&#10;&#10;    private void loadPreferences() {&#10;        SharedPreferences prefs = getSharedPreferences(PREFS, MODE_PRIVATE);&#10;        int workMin = prefs.getInt(KEY_WORK, 25);&#10;        int breakMin = prefs.getInt(KEY_BREAK, 5);&#10;        isWorkMode = prefs.getBoolean(KEY_IS_WORK, true);&#10;        workMillis = workMin * 60 * 1000L;&#10;        breakMillis = breakMin * 60 * 1000L;&#10;        sessionsCompleted = prefs.getInt(KEY_SESSIONS, 0);&#10;        if (textSessions != null) textSessions.setText(getString(R.string.sessions_label, sessionsCompleted));&#10;    }&#10;&#10;    private void savePreferences() {&#10;        SharedPreferences.Editor editor = getSharedPreferences(PREFS, MODE_PRIVATE).edit();&#10;        editor.putInt(KEY_WORK, (int) (workMillis / 60000L));&#10;        editor.putInt(KEY_BREAK, (int) (breakMillis / 60000L));&#10;        editor.putBoolean(KEY_IS_WORK, isWorkMode);&#10;        editor.putInt(KEY_SESSIONS, sessionsCompleted);&#10;        editor.apply();&#10;    }&#10;&#10;    private void startTimer() {&#10;        if (isRunning) return;&#10;        isRunning = true;&#10;        buttonPlay.setEnabled(false);&#10;        buttonPause.setEnabled(true);&#10;&#10;        long sessionTotal = isWorkMode ? workMillis : breakMillis;&#10;&#10;        // keep last progress to animate smoothly&#10;        final int[] lastProgress = {circularProgress.getProgress()};&#10;&#10;        countDownTimer = new CountDownTimer(timeLeft, 250) {&#10;            @Override&#10;            public void onTick(long millisUntilFinished) {&#10;                timeLeft = millisUntilFinished;&#10;                updateTimerText();&#10;                float fraction = (float) (sessionTotal - timeLeft) / (float) sessionTotal;&#10;                int newProgress = Math.max(0, Math.min(100, Math.round(fraction * 100)));&#10;                // animate progress from lastProgress to newProgress&#10;                ObjectAnimator anim = ObjectAnimator.ofInt(circularProgress, &quot;progress&quot;, lastProgress[0], newProgress);&#10;                anim.setDuration(220);&#10;                anim.start();&#10;                lastProgress[0] = newProgress;&#10;            }&#10;&#10;            @Override&#10;            public void onFinish() {&#10;                timeLeft = 0;&#10;                updateTimerText();&#10;                ObjectAnimator.ofInt(circularProgress, &quot;progress&quot;, 100).setDuration(200).start();&#10;                // feedback&#10;                vibrateOnFinish();&#10;                showNotification(isWorkMode ? &quot;Work complete&quot; : &quot;Break complete&quot;, isWorkMode ? &quot;Time for a break&quot; : &quot;Back to work&quot;);&#10;                // If a work session just completed, increment sessions&#10;                if (isWorkMode) {&#10;                    sessionsCompleted++;&#10;                    savePreferences();&#10;                    animateSessions();&#10;                }&#10;                // Switch mode&#10;                isWorkMode = !isWorkMode;&#10;                // subtle mode-change animation (use new mode value so label matches)&#10;                animateModeChange();&#10;                timeLeft = isWorkMode ? workMillis : breakMillis;&#10;                isRunning = false;&#10;                updateUi();&#10;                // auto-start next&#10;                startTimer();&#10;            }&#10;        };&#10;&#10;        // initial smooth progress&#10;        float fractionInit = (float) (((isWorkMode ? workMillis : breakMillis) - timeLeft)) / (float) (isWorkMode ? workMillis : breakMillis);&#10;        int initProgress = Math.max(0, Math.min(100, Math.round(fractionInit * 100)));&#10;        ObjectAnimator.ofInt(circularProgress, &quot;progress&quot;, circularProgress.getProgress(), initProgress).setDuration(200).start();&#10;        countDownTimer.start();&#10;    }&#10;&#10;    private void stopTimer() {&#10;        if (!isRunning) return;&#10;        isRunning = false;&#10;        buttonPlay.setEnabled(true);&#10;        buttonPause.setEnabled(false);&#10;        if (countDownTimer != null) {&#10;            countDownTimer.cancel();&#10;            countDownTimer = null;&#10;        }&#10;        updateUi();&#10;    }&#10;&#10;    private void animateModeChange() {&#10;        // subtle scale+fade animation on the timer and mode label&#10;        textTimer.animate().scaleX(0.92f).scaleY(0.92f).alpha(0.6f).setDuration(180).withEndAction(() -&gt; {&#10;            // restore&#10;            textTimer.setScaleX(1f);&#10;            textTimer.setScaleY(1f);&#10;            textTimer.setAlpha(1f);&#10;            textMode.setAlpha(0f);&#10;            textMode.setText(isWorkMode ? getString(R.string.mode_work) : getString(R.string.mode_break));&#10;            textMode.animate().alpha(1f).setDuration(220).start();&#10;        }).start();&#10;    }&#10;&#10;    private void animateSessions() {&#10;        if (textSessions == null) return;&#10;        textSessions.setText(getString(R.string.sessions_label, sessionsCompleted));&#10;        textSessions.animate().scaleX(1.16f).scaleY(1.16f).setDuration(160).withEndAction(() -&gt; textSessions.animate().scaleX(1f).scaleY(1f).setDuration(160).start()).start();&#10;    }&#10;&#10;    private void updateUi() {&#10;        textMode.setText(isWorkMode ? getString(R.string.mode_work) : getString(R.string.mode_break));&#10;        updateTimerText();&#10;        buttonPlay.setEnabled(!isRunning);&#10;        buttonPause.setEnabled(isRunning);&#10;        if (textSessions != null) textSessions.setText(getString(R.string.sessions_label, sessionsCompleted));&#10;    }&#10;&#10;    private void updateTimerText() {&#10;        long seconds = (timeLeft / 1000) % 60;&#10;        long minutes = (timeLeft / 1000) / 60;&#10;        String time = String.format(java.util.Locale.getDefault(), &quot;%02d:%02d&quot;, minutes, seconds);&#10;        textTimer.setText(time);&#10;    }&#10;&#10;    private void vibrateOnFinish() {&#10;        try {&#10;            Vibrator v = (Vibrator) getSystemService(VIBRATOR_SERVICE);&#10;            if (v != null &amp;&amp; v.hasVibrator()) v.vibrate(300);&#10;        } catch (SecurityException ignored) {&#10;        }&#10;    }&#10;&#10;    @Override&#10;    protected void onSaveInstanceState(Bundle outState) {&#10;        super.onSaveInstanceState(outState);&#10;        outState.putBoolean(KEY_IS_WORK, isWorkMode);&#10;        outState.putLong(KEY_TIME_LEFT, timeLeft);&#10;        outState.putBoolean(KEY_IS_RUNNING, isRunning);&#10;        outState.putInt(KEY_SESSIONS, sessionsCompleted);&#10;    }&#10;&#10;    @Override&#10;    protected void onPause() {&#10;        super.onPause();&#10;        if (countDownTimer != null) {&#10;            countDownTimer.cancel();&#10;            countDownTimer = null;&#10;        }&#10;    }&#10;&#10;    @Override&#10;    protected void onDestroy() {&#10;        super.onDestroy();&#10;        if (countDownTimer != null) {&#10;            countDownTimer.cancel();&#10;            countDownTimer = null;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.pomodorotimer;&#10;&#10;import android.animation.ObjectAnimator;&#10;import android.app.NotificationChannel;&#10;import android.app.NotificationManager;&#10;import android.content.SharedPreferences;&#10;import android.media.MediaPlayer;&#10;import android.media.Ringtone;&#10;import android.media.RingtoneManager;&#10;import android.net.Uri;&#10;import android.os.Build;&#10;import android.os.Bundle;&#10;import android.os.CountDownTimer;&#10;import android.os.Handler;&#10;import android.os.Looper;&#10;import android.os.Vibrator;&#10;import android.widget.Button;&#10;import android.widget.EditText;&#10;import android.widget.ImageButton;&#10;import android.widget.TextView;&#10;&#10;import androidx.activity.EdgeToEdge;&#10;import androidx.appcompat.app.AppCompatActivity;&#10;import androidx.core.app.NotificationCompat;&#10;import androidx.core.app.NotificationManagerCompat;&#10;import androidx.core.content.ContextCompat;&#10;import androidx.core.graphics.Insets;&#10;import androidx.core.view.ViewCompat;&#10;import androidx.core.view.WindowInsetsCompat;&#10;&#10;import com.google.android.material.bottomsheet.BottomSheetDialog;&#10;import com.google.android.material.floatingactionbutton.FloatingActionButton;&#10;import com.google.android.material.progressindicator.CircularProgressIndicator;&#10;&#10;public class MainActivity extends AppCompatActivity {&#10;&#10;    private static final String CHANNEL_ID = &quot;pomodoro_channel&quot;;&#10;&#10;    private TextView textMode;&#10;    private TextView textTimer;&#10;    private TextView textSessions; // new sessions counter&#10;    private ImageButton buttonPlay;&#10;    private ImageButton buttonPause;&#10;    private FloatingActionButton buttonSettings;&#10;    private CircularProgressIndicator circularProgress;&#10;&#10;    // MediaPlayer used for custom audio notifications (user-provided files in res/raw)&#10;    private MediaPlayer mediaPlayer;&#10;&#10;    // Handler for delayed playback and pending runnable reference so it can be cancelled&#10;    private Handler mainHandler = new Handler(Looper.getMainLooper());&#10;    private Runnable pendingSoundRunnable;&#10;&#10;    private CountDownTimer countDownTimer;&#10;    private boolean isRunning = false;&#10;    private boolean isWorkMode = true;&#10;&#10;    // Flag to make sure we play the break-preend sound only once per break session&#10;    private boolean breakPreEndPlayed = false;&#10;&#10;    // Flag indicating we already pre-played the break-start sound during the last work session&#10;    private boolean breakStartPrePlayed = false;&#10;&#10;    private long workMillis = 25 * 60 * 1000L;&#10;    private long breakMillis = 5 * 60 * 1000L;&#10;    private long timeLeft = workMillis; // milliseconds remaining&#10;&#10;    private int sessionsCompleted = 0; // persisted count&#10;&#10;    private static final String PREFS = &quot;pomodoro_prefs&quot;;&#10;    private static final String KEY_WORK = &quot;work_minutes&quot;;&#10;    private static final String KEY_BREAK = &quot;break_minutes&quot;;&#10;    private static final String KEY_IS_WORK = &quot;is_work&quot;;&#10;    private static final String KEY_TIME_LEFT = &quot;time_left&quot;;&#10;    private static final String KEY_IS_RUNNING = &quot;is_running&quot;;&#10;    private static final String KEY_SESSIONS = &quot;sessions_completed&quot;;&#10;&#10;    @Override&#10;    protected void onCreate(Bundle savedInstanceState) {&#10;        super.onCreate(savedInstanceState);&#10;        EdgeToEdge.enable(this);&#10;        setContentView(R.layout.activity_main);&#10;        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -&gt; {&#10;            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());&#10;            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);&#10;            return insets;&#10;        });&#10;&#10;        bindViews();&#10;        createNotificationChannel();&#10;        loadPreferences();&#10;&#10;        if (savedInstanceState != null) {&#10;            isWorkMode = savedInstanceState.getBoolean(KEY_IS_WORK, true);&#10;            timeLeft = savedInstanceState.getLong(KEY_TIME_LEFT, isWorkMode ? workMillis : breakMillis);&#10;            isRunning = savedInstanceState.getBoolean(KEY_IS_RUNNING, false);&#10;            sessionsCompleted = savedInstanceState.getInt(KEY_SESSIONS, sessionsCompleted);&#10;        } else {&#10;            timeLeft = isWorkMode ? workMillis : breakMillis;&#10;        }&#10;&#10;        updateUi();&#10;&#10;        buttonPlay.setOnClickListener(v -&gt; startTimer());&#10;        buttonPause.setOnClickListener(v -&gt; stopTimer());&#10;        buttonSettings.setOnClickListener(v -&gt; showSettingsSheet());&#10;&#10;        if (isRunning) startTimer();&#10;    }&#10;&#10;    private void bindViews() {&#10;        textMode = findViewById(R.id.text_mode);&#10;        textTimer = findViewById(R.id.text_timer);&#10;        textSessions = findViewById(R.id.text_sessions);&#10;        buttonPlay = findViewById(R.id.button_play);&#10;        buttonPause = findViewById(R.id.button_pause);&#10;        buttonSettings = findViewById(R.id.button_settings);&#10;        circularProgress = findViewById(R.id.circular_progress);&#10;    }&#10;&#10;    private void createNotificationChannel() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            CharSequence name = &quot;Pomodoro Alerts&quot;;&#10;            String description = &quot;Notifications for Pomodoro session events&quot;;&#10;            int importance = NotificationManager.IMPORTANCE_DEFAULT;&#10;            NotificationChannel channel = new NotificationChannel(CHANNEL_ID, name, importance);&#10;            channel.setDescription(description);&#10;            NotificationManager notificationManager = getSystemService(NotificationManager.class);&#10;            if (notificationManager != null) notificationManager.createNotificationChannel(channel);&#10;        }&#10;    }&#10;&#10;    // Play a short custom audio placed in res/raw by logical name.&#10;    // Expected raw resource names (you should add these files):&#10;    //   res/raw/work_start.mp3   -&gt; &quot;work_start&quot;&#10;    //   res/raw/work_end.mp3     -&gt; &quot;work_end&quot;  (no longer used)&#10;    //   res/raw/break_start.mp3  -&gt; &quot;break_start&quot;&#10;    //   res/raw/break_end.mp3    -&gt; &quot;break_end&quot;&#10;    // If the requested file is not present, falls back to the default notification sound.&#10;    private void playEventSound(String rawName) {&#10;        try {&#10;            stopAndReleaseMediaPlayer();&#10;            int resId = getResources().getIdentifier(rawName, &quot;raw&quot;, getPackageName());&#10;            if (resId != 0) {&#10;                mediaPlayer = MediaPlayer.create(this, resId);&#10;                if (mediaPlayer != null) {&#10;                    mediaPlayer.setOnCompletionListener(mp -&gt; stopAndReleaseMediaPlayer());&#10;                    mediaPlayer.start();&#10;                    return;&#10;                }&#10;            }&#10;&#10;            // Fallback: play default notification ringtone&#10;            Uri soundUri = RingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION);&#10;            Ringtone r = RingtoneManager.getRingtone(this, soundUri);&#10;            if (r != null) r.play();&#10;        } catch (Exception e) {&#10;            android.util.Log.w(&quot;MainActivity&quot;, &quot;playEventSound error&quot;, e);&#10;        }&#10;    }&#10;&#10;    // Play an event sound after a specified delay (milliseconds). Cancels any previously scheduled sound.&#10;    private void playEventSoundDelayed(String rawName, long delayMs) {&#10;        try {&#10;            if (mainHandler == null) mainHandler = new Handler(Looper.getMainLooper());&#10;            // Cancel previous pending sound if any&#10;            if (pendingSoundRunnable != null) {&#10;                mainHandler.removeCallbacks(pendingSoundRunnable);&#10;                pendingSoundRunnable = null;&#10;            }&#10;            pendingSoundRunnable = () -&gt; playEventSound(rawName);&#10;            mainHandler.postDelayed(pendingSoundRunnable, delayMs);&#10;        } catch (Exception e) {&#10;            android.util.Log.w(&quot;MainActivity&quot;, &quot;playEventSoundDelayed error&quot;, e);&#10;        }&#10;    }&#10;&#10;    private void stopAndReleaseMediaPlayer() {&#10;        try {&#10;            if (mediaPlayer != null) {&#10;                if (mediaPlayer.isPlaying()) mediaPlayer.stop();&#10;                mediaPlayer.reset();&#10;                mediaPlayer.release();&#10;                mediaPlayer = null;&#10;            }&#10;        } catch (Exception e) {&#10;            android.util.Log.w(&quot;MainActivity&quot;, &quot;stopAndReleaseMediaPlayer error&quot;, e);&#10;            mediaPlayer = null;&#10;        }&#10;    }&#10;&#10;    private void showNotification(String title, String text) {&#10;        // Require POST_NOTIFICATIONS on Android 13+ and check notifications are enabled&#10;        try {&#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;                if (ContextCompat.checkSelfPermission(this, android.Manifest.permission.POST_NOTIFICATIONS) != android.content.pm.PackageManager.PERMISSION_GRANTED) {&#10;                    android.util.Log.w(&quot;MainActivity&quot;, &quot;POST_NOTIFICATIONS permission not granted; skipping notification&quot;);&#10;                    return;&#10;                }&#10;            }&#10;&#10;            NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this);&#10;            if (!notificationManager.areNotificationsEnabled()) {&#10;                android.util.Log.w(&quot;MainActivity&quot;, &quot;Notifications are disabled by user; skipping notification&quot;);&#10;                return;&#10;            }&#10;&#10;            Uri soundUri = RingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION);&#10;            NotificationCompat.Builder builder = new NotificationCompat.Builder(this, CHANNEL_ID)&#10;                    .setSmallIcon(R.drawable.ic_launcher_foreground)&#10;                    .setContentTitle(title)&#10;                    .setContentText(text)&#10;                    .setPriority(NotificationCompat.PRIORITY_DEFAULT)&#10;                    .setSound(soundUri)&#10;                    .setAutoCancel(true);&#10;&#10;            try {&#10;                notificationManager.notify((int) System.currentTimeMillis(), builder.build());&#10;            } catch (SecurityException se) {&#10;                android.util.Log.w(&quot;MainActivity&quot;, &quot;Failed to post notification&quot;, se);&#10;                return;&#10;            }&#10;&#10;            // Also play the ringtone immediately (some devices delay notification sound)&#10;            try {&#10;                Ringtone r = RingtoneManager.getRingtone(this, soundUri);&#10;                if (r != null) r.play();&#10;            } catch (Exception ignored) {&#10;                android.util.Log.w(&quot;MainActivity&quot;, &quot;Failed to play notification sound&quot;, ignored);&#10;            }&#10;        } catch (Exception e) {&#10;            android.util.Log.w(&quot;MainActivity&quot;, &quot;showNotification error&quot;, e);&#10;        }&#10;    }&#10;&#10;    private void showSettingsSheet() {&#10;        try {&#10;            BottomSheetDialog dialog = new BottomSheetDialog(this);&#10;            dialog.setContentView(R.layout.bottom_sheet_settings);&#10;&#10;            final EditText bsInputWork = dialog.findViewById(R.id.bs_input_work);&#10;            final EditText bsInputBreak = dialog.findViewById(R.id.bs_input_break);&#10;            Button bsApply = dialog.findViewById(R.id.bs_apply);&#10;&#10;            if (bsInputWork != null) bsInputWork.setText(String.valueOf(workMillis / 60000L));&#10;            if (bsInputBreak != null) bsInputBreak.setText(String.valueOf(breakMillis / 60000L));&#10;&#10;            if (bsApply != null) {&#10;                bsApply.setOnClickListener(v -&gt; {&#10;                    try {&#10;                        // guard against null EditText references or null text&#10;                        if (bsInputWork == null || bsInputBreak == null) {&#10;                            dialog.dismiss();&#10;                            return;&#10;                        }&#10;                        CharSequence wCs = bsInputWork.getText();&#10;                        CharSequence bCs = bsInputBreak.getText();&#10;                        String w = wCs == null ? &quot;&quot; : wCs.toString().trim();&#10;                        String b = bCs == null ? &quot;&quot; : bCs.toString().trim();&#10;                        int wMin = 25;&#10;                        int bMin = 5;&#10;                        if (!w.isEmpty()) wMin = Integer.parseInt(w);&#10;                        if (!b.isEmpty()) bMin = Integer.parseInt(b);&#10;                        if (wMin &lt;= 0) wMin = 1;&#10;                        if (bMin &lt;= 0) bMin = 1;&#10;                        workMillis = wMin * 60 * 1000L;&#10;                        breakMillis = bMin * 60 * 1000L;&#10;                        timeLeft = isWorkMode ? workMillis : breakMillis;&#10;                        savePreferences();&#10;                        updateUi();&#10;                    } catch (Exception ex) {&#10;                        android.util.Log.w(&quot;MainActivity&quot;, &quot;Error parsing settings input&quot;, ex);&#10;                    }&#10;                    dialog.dismiss();&#10;                });&#10;            }&#10;&#10;            dialog.show();&#10;        } catch (Exception ex) {&#10;            // Catch unexpected inflation errors to avoid app crash; fallback to a simple dialog&#10;            android.util.Log.e(&quot;MainActivity&quot;, &quot;Failed to show settings sheet&quot;, ex);&#10;        }&#10;    }&#10;&#10;    private void loadPreferences() {&#10;        SharedPreferences prefs = getSharedPreferences(PREFS, MODE_PRIVATE);&#10;        int workMin = prefs.getInt(KEY_WORK, 25);&#10;        int breakMin = prefs.getInt(KEY_BREAK, 5);&#10;        isWorkMode = prefs.getBoolean(KEY_IS_WORK, true);&#10;        workMillis = workMin * 60 * 1000L;&#10;        breakMillis = breakMin * 60 * 1000L;&#10;        sessionsCompleted = prefs.getInt(KEY_SESSIONS, 0);&#10;        if (textSessions != null) textSessions.setText(getString(R.string.sessions_label, sessionsCompleted));&#10;    }&#10;&#10;    private void savePreferences() {&#10;        SharedPreferences.Editor editor = getSharedPreferences(PREFS, MODE_PRIVATE).edit();&#10;        editor.putInt(KEY_WORK, (int) (workMillis / 60000L));&#10;        editor.putInt(KEY_BREAK, (int) (breakMillis / 60000L));&#10;        editor.putBoolean(KEY_IS_WORK, isWorkMode);&#10;        editor.putInt(KEY_SESSIONS, sessionsCompleted);&#10;        editor.apply();&#10;    }&#10;&#10;    private void startTimer() {&#10;        if (isRunning) return;&#10;        isRunning = true;&#10;        buttonPlay.setEnabled(false);&#10;        buttonPause.setEnabled(true);&#10;&#10;        // Play start sound for the current mode immediately (no general delay).&#10;        // If we pre-played the break-start sound during the prior work session, consume the flag and skip double-play.&#10;        if (isWorkMode) {&#10;            // Starting a work session: play work_start and reset the pre-play flag so it may trigger again later&#10;            playEventSound(&quot;work_start&quot;);&#10;            breakStartPrePlayed = false; // ensure pre-play will be available during this work session&#10;        } else {&#10;            // Starting a break session: if break_start was already pre-played during the previous work session, consume it and do not replay.&#10;            if (breakStartPrePlayed) {&#10;                breakStartPrePlayed = false; // consumed; do not play again&#10;            } else {&#10;                playEventSound(&quot;break_start&quot;);&#10;            }&#10;        }&#10;&#10;        // Reset break pre-end flag when a new session starts&#10;        breakPreEndPlayed = false;&#10;&#10;        long sessionTotal = isWorkMode ? workMillis : breakMillis;&#10;&#10;        // keep last progress to animate smoothly&#10;        final int[] lastProgress = {circularProgress.getProgress()};&#10;&#10;        countDownTimer = new CountDownTimer(timeLeft, 250) {&#10;            @Override&#10;            public void onTick(long millisUntilFinished) {&#10;                timeLeft = millisUntilFinished;&#10;                updateTimerText();&#10;&#10;                // If we're in a work session, pre-play the break_start sound 1.5 seconds before the work session ends (once)&#10;                if (isWorkMode &amp;&amp; !breakStartPrePlayed &amp;&amp; millisUntilFinished &lt;= 1500) {&#10;                    try {&#10;                        playEventSound(&quot;break_start&quot;);&#10;                        breakStartPrePlayed = true;&#10;                    } catch (Exception e) {&#10;                        android.util.Log.w(&quot;MainActivity&quot;, &quot;Error pre-playing break_start&quot;, e);&#10;                    }&#10;                }&#10;&#10;                // If we're in a break session, play the break_end sound when 2 seconds remain (once)&#10;                if (!isWorkMode &amp;&amp; !breakPreEndPlayed &amp;&amp; millisUntilFinished &lt;= 2000) {&#10;                    try {&#10;                        // play immediately (2 seconds before end)&#10;                        playEventSound(&quot;break_end&quot;);&#10;                        breakPreEndPlayed = true;&#10;                    } catch (Exception e) {&#10;                        android.util.Log.w(&quot;MainActivity&quot;, &quot;Error playing break_end pre-sound&quot;, e);&#10;                    }&#10;                }&#10;&#10;                float fraction = (float) (sessionTotal - timeLeft) / (float) sessionTotal;&#10;                int newProgress = Math.max(0, Math.min(100, Math.round(fraction * 100)));&#10;                // animate progress from lastProgress to newProgress&#10;                ObjectAnimator anim = ObjectAnimator.ofInt(circularProgress, &quot;progress&quot;, lastProgress[0], newProgress);&#10;                anim.setDuration(220);&#10;                anim.start();&#10;                lastProgress[0] = newProgress;&#10;            }&#10;&#10;            @Override&#10;            public void onFinish() {&#10;                // When a session finishes we switch modes and auto-start the next session.&#10;                // The next session's start sound is played by startTimer() when it begins.&#10;&#10;                timeLeft = 0;&#10;                updateTimerText();&#10;                ObjectAnimator.ofInt(circularProgress, &quot;progress&quot;, 100).setDuration(200).start();&#10;                // feedback&#10;                vibrateOnFinish();&#10;                showNotification(isWorkMode ? &quot;Work complete&quot; : &quot;Break complete&quot;, isWorkMode ? &quot;Time for a break&quot; : &quot;Back to work&quot;);&#10;                // If a work session just completed, increment sessions&#10;                if (isWorkMode) {&#10;                    sessionsCompleted++;&#10;                    savePreferences();&#10;                    animateSessions();&#10;                }&#10;                // Switch mode&#10;                isWorkMode = !isWorkMode;&#10;                // subtle mode-change animation (use new mode value so label matches)&#10;                animateModeChange();&#10;                timeLeft = isWorkMode ? workMillis : breakMillis;&#10;                isRunning = false;&#10;                updateUi();&#10;                // auto-start next (startTimer will play the start sound immediately)&#10;                startTimer();&#10;            }&#10;        };&#10;&#10;        // initial smooth progress&#10;        float fractionInit = (float) (((isWorkMode ? workMillis : breakMillis) - timeLeft)) / (float) (isWorkMode ? workMillis : breakMillis);&#10;        int initProgress = Math.max(0, Math.min(100, Math.round(fractionInit * 100)));&#10;        ObjectAnimator.ofInt(circularProgress, &quot;progress&quot;, circularProgress.getProgress(), initProgress).setDuration(200).start();&#10;        countDownTimer.start();&#10;    }&#10;&#10;    private void stopTimer() {&#10;        if (!isRunning) return;&#10;        isRunning = false;&#10;        buttonPlay.setEnabled(true);&#10;        buttonPause.setEnabled(false);&#10;        if (countDownTimer != null) {&#10;            countDownTimer.cancel();&#10;            countDownTimer = null;&#10;        }&#10;        // Cancel any pending sound callbacks&#10;        if (mainHandler != null &amp;&amp; pendingSoundRunnable != null) {&#10;            mainHandler.removeCallbacks(pendingSoundRunnable);&#10;            pendingSoundRunnable = null;&#10;        }&#10;        // reset break pre-end flag&#10;        breakPreEndPlayed = false;&#10;        updateUi();&#10;    }&#10;&#10;    private void animateModeChange() {&#10;        // subtle scale+fade animation on the timer and mode label&#10;        textTimer.animate().scaleX(0.92f).scaleY(0.92f).alpha(0.6f).setDuration(180).withEndAction(() -&gt; {&#10;            // restore&#10;            textTimer.setScaleX(1f);&#10;            textTimer.setScaleY(1f);&#10;            textTimer.setAlpha(1f);&#10;            textMode.setAlpha(0f);&#10;            textMode.setText(isWorkMode ? getString(R.string.mode_work) : getString(R.string.mode_break));&#10;            textMode.animate().alpha(1f).setDuration(220).start();&#10;        }).start();&#10;    }&#10;&#10;    private void animateSessions() {&#10;        if (textSessions == null) return;&#10;        textSessions.setText(getString(R.string.sessions_label, sessionsCompleted));&#10;        textSessions.animate().scaleX(1.16f).scaleY(1.16f).setDuration(160).withEndAction(() -&gt; textSessions.animate().scaleX(1f).scaleY(1f).setDuration(160).start()).start();&#10;    }&#10;&#10;    private void updateUi() {&#10;        textMode.setText(isWorkMode ? getString(R.string.mode_work) : getString(R.string.mode_break));&#10;        updateTimerText();&#10;        buttonPlay.setEnabled(!isRunning);&#10;        buttonPause.setEnabled(isRunning);&#10;        if (textSessions != null) textSessions.setText(getString(R.string.sessions_label, sessionsCompleted));&#10;    }&#10;&#10;    private void updateTimerText() {&#10;        long seconds = (timeLeft / 1000) % 60;&#10;        long minutes = (timeLeft / 1000) / 60;&#10;        String time = String.format(java.util.Locale.getDefault(), &quot;%02d:%02d&quot;, minutes, seconds);&#10;        textTimer.setText(time);&#10;    }&#10;&#10;    private void vibrateOnFinish() {&#10;        try {&#10;            Vibrator v = (Vibrator) getSystemService(VIBRATOR_SERVICE);&#10;            if (v != null &amp;&amp; v.hasVibrator()) v.vibrate(300);&#10;        } catch (SecurityException ignored) {&#10;        }&#10;    }&#10;&#10;    @Override&#10;    protected void onSaveInstanceState(Bundle outState) {&#10;        super.onSaveInstanceState(outState);&#10;        outState.putBoolean(KEY_IS_WORK, isWorkMode);&#10;        outState.putLong(KEY_TIME_LEFT, timeLeft);&#10;        outState.putBoolean(KEY_IS_RUNNING, isRunning);&#10;        outState.putInt(KEY_SESSIONS, sessionsCompleted);&#10;    }&#10;&#10;    @Override&#10;    protected void onPause() {&#10;        super.onPause();&#10;        if (countDownTimer != null) {&#10;            countDownTimer.cancel();&#10;            countDownTimer = null;&#10;        }&#10;    }&#10;&#10;    @Override&#10;    protected void onDestroy() {&#10;        super.onDestroy();&#10;        if (countDownTimer != null) {&#10;            countDownTimer.cancel();&#10;            countDownTimer = null;&#10;        }&#10;        // Cancel pending sound callbacks and release player&#10;        if (mainHandler != null &amp;&amp; pendingSoundRunnable != null) {&#10;            mainHandler.removeCallbacks(pendingSoundRunnable);&#10;            pendingSoundRunnable = null;&#10;        }&#10;        stopAndReleaseMediaPlayer();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>